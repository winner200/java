public class DataType08 {
	public static void main(String[] args) {
		// 100L是long类型字面值
		// x是long类型变量
		// 不存在类型转换，直接赋值
		long x = 100L;
		
		// x变量是long类型，8个字节
		// y变量是int类型，4个字节
		// 以下程序可以编译通过吗？
		// 编译报错，大容量不能直接赋值给小容量
		//int y = x;
		
		// 大容量转换成小容量，需要进行强制类型转换
		// 强制类型转换需要加“强制类型转换符”
		// 加上强制类型转换符之后编译通过了，但是在运行阶段可能损失精度。
		// 所以强制类型转换谨慎使用，因为损失精度以后可能损失很严重。
		
		/*
			强转原理：
				原始数据：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
				强转之后的数据：00000000 00000000 00000000 01100100
				将左边的二进制砍掉【所有的数据强转的时候都是这样完成的】
		*/
		int y = (int)x;
		System.out.println(y);
		
		// 原始数据：00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
		// 强转之后的数据：10000000 00000000 00000000 00000000
		// 10000000 00000000 00000000 00000000目前存储在计算机内部，计算机存储数据都是采用补码的形式存储，
		// 所以10000000 00000000 00000000 00000000现在是一个补码形式。将以上的补码转换到原码就是最终的结果。
		
		long k = 2147483648L;
		int e = (int)k;
		System.out.println(e); // 损失精度严重，结果是负数。【-2147483648】
		
		// 分析以下程序是否可以编译通过？
		// 依据目前所学内容，以下程序是无法编译通过的。
		// 理由：50是int类型的字面值，b是byte类型的变量，显然是大容量int转换成小容量byte。
		// 大容量转换成小容量需要添加强制类型转换符的，以下程序没有添加强转符号，所以编译报错。
		// 但是在实际编译的时候，以下代码编译通过了。这说明，在java语言当中，当一个整数型字面值没有超出byte类型取值范围的话，该字面值可以直接赋值给byte类型的变量。
		byte b = 50; // 可以
		
		byte c = 127; // 可以
		
		//byte b1 = 128; // 编译报错，128这个int类型的字面值已经超出了byte类型的取值范围，不能直接赋值给byte类型的变量。
		
		// 纠正错误，需要使用强制类型转换符，但是一定会损失精度。
		// 原始数据：00000000 00000000 00000000 10000000
		// 强转之后：10000000 【这是存储在计算机内部的，这是衣蛾补码，他的源码是什么？】
		byte b1 = (byte)128; // -128
		System.out.println(b1);
		
		/*
			计算机二进制有三种表示形式：
				原码
				反码
				补码
			计算机在任何情况下底层表示和存储数据的时候采用了补码形式。
			正数的补码：和原码相同
			负数的补码：负数的绝对值对应的二进制码所有二进制位取反，再加1
			
			补码：10000000
			原码计算过程：
				* 1000000 - 1 --> 01111111
				* 1000000 --> 128
				* -128
		*/
		
		// 原始数据：00000000 00000000 00000000 11000110
		// 强制类型转换之后：11000110
		// 11000110现在是计算机当中存储，他是一个补码，将补码转换成原码就是该数字。
		// 11000110 - 1 ---> 11000101
		// 00111010 【2 + 8 + 16 + 32】---58
		// -58
		byte m = (byte)198;
		System.out.println(m);
		
		short s = 32767; // 通过
		short s1 = 32768; // 编译报错
		
		// 65535是int类型，4个字节，cc是char类型，2个字节，按照以前所学的知识，以下程序是编译报错的。
		char cc = 65535;
		cc = 65536;
		
		/*
			当一个整数字面值没有超出byte、short、char的取值范围，
			这个字面值可以直接赋给byte,short,char类型的变量。
			这种机制SUN允许了，目的是为了方便程序员编程。
		*/
	}
}



















